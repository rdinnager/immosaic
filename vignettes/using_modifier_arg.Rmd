---
title: "Using modifier argument for advanced packed image mosaics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using modifier argument for advanced packed image mosaics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(impac)
library(imager)
```

In this vignette we will see how to use the `modifier` argument of `impac` to create more complicated packed image mosaics. By passing a function or expression to `modifier` we can modify an image after it has been assigned a position and size on the canvas but before it is actually added to the image. This let's us change the image based on its size or position. We will demonstrate this by recreating the `impac` package logo image. The logo is created by packing 'gem-like' images (created with the `rgl` package) and changing their colours based on whether they overlap an image of the word `impac`. I created this image earlier, so the first thing we will do it load it and take a look.

```{r load_logo_text}
logo_text <- load.image("vignettes/figures/impac_text.png") %>%
  flatten.alpha() 
logo_text <- logo_text %>%
  pad((512 - height(logo_text)), "y", val = "white") %>%
  grayscale()
plot(logo_text)
logo_text <- resize_doubleXY(logo_text)
logo_text <- round(1 - logo_text)
```

Okay, now we create a modifier function that compares the position of the packed image to the text image and converts it to grayscale its does not overlap any of the letters, or white if it overlaps the letters' borders (to give a nice outline). In `impac` we can use any `impac`-context variables in out function. See documentation of `impac` for a list of available context variables. We will use the `.x`, `.y`, and `.img` context variables which are the x, and y coordinates, and the resized image just packed, respectively. A modifier function must return a `cimg` object.

```{r modifier_fun}
make_gray <- function() {
  img <- .img
  
  text_mask <- round(logo_text[.bb[1]:.bb[2], .bb[3]:.bb[4], , , drop = FALSE])
  
  img_mask <- round(imager::channel(img, 4))
  composite <- imager::parmin(list(text_mask, img_mask)) > 0
  
  ## completely outside letter
  if(all(!composite)) {
    new_img <- flatten.alpha(img) %>%  
    grayscale(drop = FALSE)
    img[ , , , 1:3] <- new_img
  } else {
    # completely inside letter
    if(!all(text_mask[round(img_mask) > 0] > 0)) {
      ## overlaps border
      img[ , , , 4] <- 0
    }
  }
  
  img
    
}
```

We will also use a new `scaler` function to scale any packed images based on whether they fall inside the lettering or not.

Okay, now we can use our gem generating `im` function (as seen in the `impac` readme) with our modifier function and see what we get.

```{r make_platonic}
generate_platonic <- function(i, swidth = 200, sheight = 200, cols = rainbow(100)) {
  
  shape <- sample(c("sphere",
                    "spherical_cap",
                    "tetrahedron",
                    "dodecahedron",
                    "octahedron",
                    "icosahedron",
                    "hexahedron",
                    "cube",
                    "cone"),
                  1)
  
  mesh <- switch (shape,
    sphere = Rvcg::vcgSphere(),
    spherical_cap = Rvcg::vcgSphericalCap(),
    tetrahedron = Rvcg::vcgTetrahedron(),
    dodecahedron = Rvcg::vcgDodecahedron(),
    octahedron = Rvcg::vcgOctahedron(),
    icosahedron = Rvcg::vcgIcosahedron(),
    hexahedron = Rvcg::vcgHexahedron(),
    cube = Rvcg::vcgBox(),
    cone = Rvcg::vcgCone(2, 0, 6)
  )
  
  scales <- c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 3, 4)
  mesh <- rgl::scale3d(mesh, 
                       sample(scales, 1),
                       sample(scales, 1),
                       sample(scales, 1))
  
  mesh <- rgl::rotate3d(mesh, runif(1, 0, 2 * pi), 0, 0, 1)
  mesh <- rgl::rotate3d(mesh, runif(1, 0, 2 * pi), 0, 1, 0)
  mesh <- rgl::rotate3d(mesh, runif(1, 0, 2 * pi), 1, 0, 0)
  
  rgl::shade3d(mesh, col = sample(cols, 1),
               specular = "grey")
  
  png_file <- tempfile(fileext = ".png")
  rgl::snapshot3d(filename = png_file, width = swidth, height = sheight,
                  webshot = FALSE)
  rgl::close3d()
  
  im2 <- imager::load.image(png_file)
  im <- imager::imfill(swidth, sheight, val = c(0, 0, 0, 1))
  im[ , , , 1:3] <- im2 
  im[imager::R(im) == 1 & imager::G(im) == 1 & imager::B(im) == 1] <- 0
  
  im  
 
}
```

Run `impac`:

```{r run_impac}
logo <- impac(generate_platonic, progress = TRUE, show_every = 10, 
              modifier = make_gray, width = 1024, height = 1024,
              bg = "white",
              min_scale = 0.001,
              terminater = {
                space_left() < 0.1
              })
```
